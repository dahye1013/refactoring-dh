## 들어가며

- **모듈을 분리하는 가장 중요한 기준?**

  ⇒ 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있다.

  - 대표적인 방법
    1. 레코드 캡슐화하기
    2. 컬렉션 캡슐화하기

- **클래스는 본래 정보를 숨기는 용도로 설계 되었다.**

  - 여러 함수를 클래스에 묶기(6.9장)
  - 클래스 추출하기(7.5장)
  - 클래스 인라인하기(7.6장)

- **클래스는 연결 관계를 숨기는 데도 유용하다**

  - 위임 숨기기(7.7장)
    → 하지만, 너무 많이 숨기면 인터페이스가 비대해진다.
    ⇒ 중개자 제거하기(7.8장)을 이용할 수 있다.

- **가장 큰 캡슐화 단위는 클래스와 모듈이지만 함수도 구현을 캡슐화 한다.**
  → 알고리즘을 통째로 바꿔야 할 떄가 있는데, 함수 추출하기(6.1장)로 알고리즘 전체를 함수 하나에 담은 뒤 알고리즘 교체하기(7.9장) 에 적용하면 된다.

## 7.1장 레코드 캡슐화하기

대부분의 프로그래밍 언어는 데이터 레코드는 표현하는 구조를 제공한다.

→ 직관적인 방식으로 묶으면 각각을 취급할 때보다 의미있는 단위로 전달한다.

**단순한 레코드의 단점**

→ 값을 명확히 구분해야 하는 점이 번거롭다.

⇒ 객체를 사용하면 어떻게 저장했는지 숨긴 채 각 메서드로 제공가능하다.

**레코드 두가지 구조**

1. 필드 이름을 노출하는 형태
2. 원하는 이름을 쓸 수 있는 형태

   → 주로 라이브러리에서 해쉬, 맵, 해쉬맵, 딕셔너리, 연관 배열로 제공한다.

- 코드를 작성하나보면 중첩된 리스트나 해쉬맵을 받아서 JSON이나 XML 포멧으로 직렬화 할 떄가 많다.
  ⇒ 이런 구조 역시 캡슐화 할 수 있다.
  ⇒ 데이터 수정이 쉬워진다.

> **절차**
>
> 1. 레코드를 담은 변수를 캡슐화 한다.
>
>    → 레코드를 캡슐화하는 함수 이름을 검색하기 쉽게 지어준다.
>
> 2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다.
> 3. 테스트한다.
> 4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
> 5. 레코드를 반호나하는 예전 함수를 사용하는 코드를 새 함수를 사용하도록 바꾼다.
> 6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다.
> 7. 테스트한다.
> 8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐하기를 재귀적으로 적용한다.

## 7.2 컬렉션 캡슐화하기

**가변데이터 캡슐화 장점**

- 데이터 구조가 언제 어떻게 수정되는지 파악하기 쉽다.
- 필요한 시점에 데이터 구조를 변경하기 쉽다.

**클래스 컬렉션**

— 유의할 점 : 컬렉션 변수 접근을 캡슐화하면서 게터가 컬렉션을 반환하면, 컬렉션 원소가 바뀐다.

- **변경방식 -** 컬렉션을 감싼 클랙스에 add() , remove() 와 같은 컬렉션 변경자 메서드를 만든다.
- 컬렉션 게터가 원본 컬렉션을 반환하지 않도록 만들어서 실수 방지
  - 컬렉션을 읽기 전용으로만 사용한다.
    → 이터레이터나 열거형 객체 기반 라이브러리도 유사한 방법을 사용한다.
    → 컬렉션 게터를 제공하되 내부 컬렉션 복제본을 반환하도록 한다.

> **절차**
>
> 1. 컬렉션을 캡슐화한다
> 2. 원소를 추가/ 제거하는 함수를 추가한다.
>    1. 컬렉션 자체는 통쨰로 바꾸는 세터를 제거한다.
> 3. 정적 검사를 수행한다.
> 4. 컬렉션 참조하는 부분을 모두 찾아서 바꾼다.
> 5. 원본 내용을 수정할 수 없는 읽기 전용 프락시나 복제본을 반환한다.
> 6. 테스트한다.

## 7.3 기본형을 객체로 바꾸기

개발 초기에느 단순한 정보나 숫자를 간단한 데이터로 표현한다.

개발이 진행되면서 출력이상이 필요하면 전용 클래스로 변환하면, 유용한 도구가 된다

> **절차**
>
> 1. 캡슐화한다.
> 2. 값 클래스를 만든다.
> 3. 정적 검사를 수행한다.
> 4. 인스턴스를 만들어서 필드 저장하는 세터를 수정한다.
> 5. 클래스 게터 호출 결과를 반환하도록 게터를 수정한다.
> 6. 테스트
> 7. 이름 바꿀때 접근자 동작을 더 잘 들러내는지 검토한다.

## 7.4 임시 변수를 질의 함수로 바꾸기

**임시 변수 사용**

- 값을 계산하는 코드가 반복되는 것을 줄인다.
- 값의 의미를 설명 할 수도 있어서 유용하다.

**긴 함수**

- 한 부분을 별도 함수로 추출시
  - 변수들을 각각의 함수로 만들면 수월하다.
  - 함수에 변수를 따로 전달 할 필요가 없다
    → 추출함수와 원래 함수 경계가 분명해진다.
    ⇒ 부자연스러운 의존관계나 부수 효과를 찾아 제거하는데 유용하다.

**변수 대신 함수로 만들기**

- 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있다.
- 코드 중복이 줄어든다.

**임시 변수를 질의함수로 바꾸기**는 클래스 안에서 적용할떄 효과가 가장 크다

- 클래스를 추출할 메서드들에 공유 컨텍스트를 제공하기 때문이다.
- 클래스 밖에 최상위 함수로 추출하면 매개변수가 너무 많아서 함수를 사용하는 장점이 줄어든다.
- 중첩함수를 사용하면 로직을 널리 공유하는데 한계가 있다.
  → 변수는 값을 한 번만 계산하고, 그 뒤로는 읽기만 해야 한다.
  다시 대입하는 경우 모두 질의 함수로 추출해야한다.

> **절차**
>
> 1. 변수가 사용되기 전에 값이 확실히 결정되는지, 계산 로직이 매번 다른 결과를 내지는 않는지 확인한다.
> 2. 읽기전용으로 만들 수 있는 변수는 읽기전용으로 만든다.
> 3. 테스트
> 4. 변수 대입문을 함수로 추출한다.
>
>    → 변수와 함수가 같은 이름을 가질 수 없다면 함수 이름을 임시로 짓는다.
>
>    → 추출 함수가 부수 효과를 일으키지는 않는지 확인한다.
>
>    ⇒ 부수효과가 있으면, 질의 함수와 변경 함수 분리하기로 대처한다.
>
> 5. 테스트
> 6. 변수 인라인하기로 임시 변수를 제거한다.
